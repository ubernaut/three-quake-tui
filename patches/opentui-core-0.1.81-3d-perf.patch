--- a/node_modules/@opentui/core/3d.js
+++ b/node_modules/@opentui/core/3d.js
@@ -31254,12 +31254,10 @@
 
 // src/3d/shaders/supersampling.wgsl
 var supersampling_default = `struct CellResult {
-    bg: vec4<f32>,      // Background RGBA (16 bytes)
-    fg: vec4<f32>,      // Foreground RGBA (16 bytes)
-    char: u32,          // Unicode character code (4 bytes)
-    _padding1: u32,     // Padding (4 bytes)
-    _padding2: u32,     // Extra padding (4 bytes) 
-    _padding3: u32,     // Extra padding (4 bytes) - total now 48 bytes (16-byte aligned)
+    bg: u32,            // Packed RGB8 background
+    fg: u32,            // Packed RGB8 foreground
+    char: u32,          // Unicode character code
+    meta: u32,          // Reserved for future flags/attrs (keeps 16-byte alignment)
 };
 
 struct CellBuffer {
@@ -31350,6 +31348,13 @@
     return blendColors(blend1, blend2);
 }
 
+fn packRgb8(color: vec4<f32>) -> u32 {
+    let r = u32(round(clamp(color.r, 0.0, 1.0) * 255.0));
+    let g = u32(round(clamp(color.g, 0.0, 1.0) * 255.0));
+    let b = u32(round(clamp(color.b, 0.0, 1.0) * 255.0));
+    return r | (g << 8u) | (b << 16u);
+}
+
 fn renderQuadrantBlock(pixels: array<vec4<f32>, 4>) -> CellResult {
     var maxDist: f32 = colorDistance(pixels[0], pixels[1]);
     var pIdxA: u32 = 0u;
@@ -31394,20 +31399,18 @@
     
     if (quadrantBits == 0u) { // All light
         result.char = 32u; // Space character
-        result.fg = chosenDarkColor;
-        result.bg = averageColorsWithAlpha(pixels);
+        result.fg = packRgb8(chosenDarkColor);
+        result.bg = packRgb8(averageColorsWithAlpha(pixels));
     } else if (quadrantBits == 15u) { // All dark  
         result.char = quadrantChars[15]; // Full block
-        result.fg = averageColorsWithAlpha(pixels);
-        result.bg = chosenLightColor;
+        result.fg = packRgb8(averageColorsWithAlpha(pixels));
+        result.bg = packRgb8(chosenLightColor);
     } else { // Mixed pattern
         result.char = quadrantChars[quadrantBits];
-        result.fg = chosenDarkColor;
-        result.bg = chosenLightColor;
+        result.fg = packRgb8(chosenDarkColor);
+        result.bg = packRgb8(chosenLightColor);
     }
-    result._padding1 = 0u;
-    result._padding2 = 0u;
-    result._padding3 = 0u;
+    result.meta = 0u;
     
     return result;
 }
@@ -31467,6 +31470,9 @@
 class CLICanvas {
   device;
   readbackBuffer = null;
+  readbackBuffers = [];
+  readbackBufferRingIndex = 0;
+  pendingReadbackFrame = null;
   width;
   height;
   gpuCanvasContext;
@@ -31492,6 +31498,25 @@
   }
   destroy() {
     this.destroyed = true;
+    this.clearPendingReadbackFrame();
+    for (const readbackBuffer of this.readbackBuffers) {
+      try {
+        readbackBuffer.destroy();
+      } catch (error) {
+      }
+    }
+    this.readbackBuffers = [];
+  }
+  clearPendingReadbackFrame() {
+    const pending = this.pendingReadbackFrame;
+    this.pendingReadbackFrame = null;
+    if (!pending || !pending.buffer) {
+      return;
+    }
+    try {
+      pending.buffer.unmap();
+    } catch (error) {
+    }
   }
   setSuperSampleAlgorithm(superSampleAlgorithm) {
     this.superSampleAlgorithm = superSampleAlgorithm;
@@ -31640,7 +31665,7 @@
     if (this.superSample === "none" /* NONE */)
       return;
     this.updateComputeParams();
-    const cellBytesSize = 48;
+    const cellBytesSize = 16;
     const terminalWidthCells = Math.floor((width + 1) / 2);
     const terminalHeightCells = Math.floor((height + 1) / 2);
     const outputBufferSize = terminalWidthCells * terminalHeightCells * cellBytesSize;
@@ -31707,27 +31732,47 @@
       this.computeReadbackBuffer.unmap();
       return;
     }
-    const resultsPtr = this.computeReadbackBuffer.getMappedRangePtr();
-    const size = this.computeReadbackBuffer.size;
     this.mapAsyncTimeMs = performance.now() - mapAsyncStart;
     const ssStart = performance.now();
-    buffer.drawPackedBuffer(resultsPtr, size, 0, 0, terminalWidthCells, terminalHeightCells);
+    const packedRange = this.computeReadbackBuffer.getMappedRange();
+    const packedWords = new Uint32Array(packedRange);
+    for (let cellY = 0; cellY < terminalHeightCells; cellY++) {
+      for (let cellX = 0; cellX < terminalWidthCells; cellX++) {
+        const wordIndex = (cellY * terminalWidthCells + cellX) * 4;
+        const bgPacked = packedWords[wordIndex];
+        const fgPacked = packedWords[wordIndex + 1];
+        const charCode = packedWords[wordIndex + 2] || 32;
+        const fgColor = RGBA.fromValues((fgPacked & 255) / 255, (fgPacked >> 8 & 255) / 255, (fgPacked >> 16 & 255) / 255, 1);
+        const bgColor = RGBA.fromValues((bgPacked & 255) / 255, (bgPacked >> 8 & 255) / 255, (bgPacked >> 16 & 255) / 255, 1);
+        buffer.setCellWithAlphaBlending(cellX, cellY, String.fromCodePoint(charCode), fgColor, bgColor);
+      }
+    }
     this.superSampleDrawTimeMs = performance.now() - ssStart;
     this.computeReadbackBuffer.unmap();
   }
   updateReadbackBuffer(renderWidth, renderHeight) {
-    if (this.readbackBuffer) {
-      this.readbackBuffer.destroy();
+    this.clearPendingReadbackFrame();
+    for (const readbackBuffer of this.readbackBuffers) {
+      try {
+        readbackBuffer.destroy();
+      } catch (error) {
+      }
     }
+    this.readbackBuffers = [];
     const bytesPerPixel = 4;
     const unalignedBytesPerRow = renderWidth * bytesPerPixel;
     const alignedBytesPerRow = Math.ceil(unalignedBytesPerRow / 256) * 256;
     const textureBufferSize = alignedBytesPerRow * renderHeight;
-    this.readbackBuffer = this.device.createBuffer({
-      label: "Readback Buffer",
-      size: textureBufferSize,
-      usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
-    });
+    const ringSize = 2;
+    for (let i = 0; i < ringSize; i++) {
+      this.readbackBuffers.push(this.device.createBuffer({
+        label: `Readback Buffer ${i}`,
+        size: textureBufferSize,
+        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST
+      }));
+    }
+    this.readbackBufferRingIndex = 0;
+    this.readbackBuffer = this.readbackBuffers[0] ?? null;
   }
   async readPixelsIntoBuffer(buffer) {
     if (this.destroyed) {
@@ -31739,44 +31784,61 @@
       await this.runComputeShaderSuperSampling(texture, buffer);
       return;
     }
-    const textureBuffer = this.readbackBuffer;
-    if (!textureBuffer) {
+    const textureBuffers = this.readbackBuffers.length > 0 ? this.readbackBuffers : this.readbackBuffer ? [this.readbackBuffer] : [];
+    if (textureBuffers.length === 0) {
       throw new Error("Readback buffer not found");
     }
+    const bytesPerPixel = 4;
+    const unalignedBytesPerRow = this.width * bytesPerPixel;
+    const alignedBytesPerRow = Math.ceil(unalignedBytesPerRow / 256) * 256;
+    const contextFormat = texture.format;
+    const currentTextureBuffer = textureBuffers[this.readbackBufferRingIndex % textureBuffers.length];
+    this.readbackBufferRingIndex = (this.readbackBufferRingIndex + 1) % textureBuffers.length;
+    const commandEncoder = this.device.createCommandEncoder({ label: "Readback Command Encoder" });
+    commandEncoder.copyTextureToBuffer({ texture }, { buffer: currentTextureBuffer, bytesPerRow: alignedBytesPerRow, rowsPerImage: this.height }, {
+      width: this.width,
+      height: this.height
+    });
+    const commandBuffer = commandEncoder.finish();
+    this.device.queue.submit([commandBuffer]);
+    const currentPending = {
+      buffer: currentTextureBuffer,
+      width: this.width,
+      height: this.height,
+      alignedBytesPerRow,
+      contextFormat,
+      mapStart: performance.now(),
+      mapPromise: currentTextureBuffer.mapAsync(GPUMapMode.READ, 0, currentTextureBuffer.size)
+    };
+    const previousPending = this.pendingReadbackFrame;
+    this.pendingReadbackFrame = currentPending;
+    if (!previousPending) {
+      this.mapAsyncTimeMs = 0;
+      this.superSampleDrawTimeMs = 0;
+      return;
+    }
     try {
-      const bytesPerPixel = 4;
-      const unalignedBytesPerRow = this.width * bytesPerPixel;
-      const alignedBytesPerRow = Math.ceil(unalignedBytesPerRow / 256) * 256;
-      const contextFormat = texture.format;
-      const commandEncoder = this.device.createCommandEncoder({ label: "Readback Command Encoder" });
-      commandEncoder.copyTextureToBuffer({ texture }, { buffer: textureBuffer, bytesPerRow: alignedBytesPerRow, rowsPerImage: this.height }, {
-        width: this.width,
-        height: this.height
-      });
-      const commandBuffer = commandEncoder.finish();
-      this.device.queue.submit([commandBuffer]);
-      const mapStart = performance.now();
-      await textureBuffer.mapAsync(GPUMapMode.READ, 0, textureBuffer.size);
-      this.mapAsyncTimeMs = performance.now() - mapStart;
+      await previousPending.mapPromise;
+      this.mapAsyncTimeMs = performance.now() - previousPending.mapStart;
       if (this.destroyed) {
-        textureBuffer.unmap();
+        previousPending.buffer.unmap();
         return;
       }
-      const mappedRangePtr = textureBuffer.getMappedRangePtr(0, textureBuffer.size);
+      const mappedRangePtr = previousPending.buffer.getMappedRangePtr(0, previousPending.buffer.size);
       const bufPtr = mappedRangePtr;
       if (this.superSample === "cpu" /* CPU */) {
-        const format = contextFormat === "bgra8unorm" ? "bgra8unorm" : "rgba8unorm";
+        const format = previousPending.contextFormat === "bgra8unorm" ? "bgra8unorm" : "rgba8unorm";
         const ssStart = performance.now();
-        buffer.drawSuperSampleBuffer(0, 0, bufPtr, textureBuffer.size, format, alignedBytesPerRow);
+        buffer.drawSuperSampleBuffer(0, 0, bufPtr, previousPending.buffer.size, format, previousPending.alignedBytesPerRow);
         this.superSampleDrawTimeMs = performance.now() - ssStart;
       } else {
         this.superSampleDrawTimeMs = 0;
-        const pixelData = new Uint8Array(toArrayBuffer(bufPtr, 0, textureBuffer.size));
-        const isBGRA = contextFormat === "bgra8unorm";
+        const pixelData = new Uint8Array(toArrayBuffer(bufPtr, 0, previousPending.buffer.size));
+        const isBGRA = previousPending.contextFormat === "bgra8unorm";
         const backgroundColor = RGBA.fromValues(0, 0, 0, 1);
-        for (let y2 = 0;y2 < this.height; y2++) {
-          for (let x2 = 0;x2 < this.width; x2++) {
-            const pixelIndexInPaddedRow = y2 * alignedBytesPerRow + x2 * bytesPerPixel;
+        for (let y2 = 0;y2 < previousPending.height; y2++) {
+          for (let x2 = 0;x2 < previousPending.width; x2++) {
+            const pixelIndexInPaddedRow = y2 * previousPending.alignedBytesPerRow + x2 * bytesPerPixel;
             if (pixelIndexInPaddedRow + 3 >= pixelData.length)
               continue;
             let rByte, gByte, bByte;
@@ -31798,7 +31860,10 @@
         }
       }
     } finally {
-      textureBuffer.unmap();
+      try {
+        previousPending.buffer.unmap();
+      } catch (error) {
+      }
     }
   }
 }

{
  "version": 3,
  "sources": ["../src/lib/tree-sitter/parser.worker.ts", "../src/lib/tree-sitter/download-utils.ts", "../src/lib/bunfs.ts"],
  "sourcesContent": [
    "import { Parser, Query, Tree, Language } from \"web-tree-sitter\"\nimport type { Edit, QueryCapture, Range } from \"web-tree-sitter\"\nimport { mkdir } from \"fs/promises\"\nimport * as path from \"path\"\nimport type {\n  HighlightRange,\n  HighlightResponse,\n  SimpleHighlight,\n  FiletypeParserOptions,\n  PerformanceStats,\n  InjectionMapping,\n} from \"./types\"\nimport { DownloadUtils } from \"./download-utils\"\nimport { isMainThread } from \"worker_threads\"\nimport { isBunfsPath, normalizeBunfsPath } from \"../bunfs\"\n\nconst self = globalThis\n\ntype ParserState = {\n  parser: Parser\n  tree: Tree\n  queries: {\n    highlights: Query\n    injections?: Query\n  }\n  filetype: string\n  content: string\n  injectionMapping?: InjectionMapping\n}\n\ninterface FiletypeParser {\n  filetype: string\n  queries: {\n    highlights: Query\n    injections?: Query\n  }\n  language: Language\n  injectionMapping?: InjectionMapping\n}\n\ninterface ReusableParserState {\n  parser: Parser\n  filetypeParser: FiletypeParser\n  queries: {\n    highlights: Query\n    injections?: Query\n  }\n}\n\nclass ParserWorker {\n  private bufferParsers: Map<number, ParserState> = new Map()\n  private filetypeParserOptions: Map<string, FiletypeParserOptions> = new Map()\n  private filetypeParsers: Map<string, FiletypeParser> = new Map()\n  private filetypeParserPromises: Map<string, Promise<FiletypeParser | undefined>> = new Map()\n  private reusableParsers: Map<string, ReusableParserState> = new Map()\n  private reusableParserPromises: Map<string, Promise<ReusableParserState | undefined>> = new Map()\n  private initializePromise: Promise<void> | undefined\n  public performance: PerformanceStats\n  private dataPath: string | undefined\n  private tsDataPath: string | undefined\n  private initialized: boolean = false\n\n  constructor() {\n    this.performance = {\n      averageParseTime: 0,\n      parseTimes: [],\n      averageQueryTime: 0,\n      queryTimes: [],\n    }\n  }\n\n  private async fetchQueries(sources: string[], filetype: string): Promise<string> {\n    if (!this.tsDataPath) {\n      return \"\"\n    }\n    return DownloadUtils.fetchHighlightQueries(sources, this.tsDataPath, filetype)\n  }\n\n  async initialize({ dataPath }: { dataPath: string }) {\n    if (this.initializePromise) {\n      return this.initializePromise\n    }\n    this.initializePromise = new Promise(async (resolve, reject) => {\n      this.dataPath = dataPath\n      this.tsDataPath = path.join(dataPath, \"tree-sitter\")\n\n      try {\n        await mkdir(path.join(this.tsDataPath, \"languages\"), { recursive: true })\n        await mkdir(path.join(this.tsDataPath, \"queries\"), { recursive: true })\n\n        let { default: treeWasm } = await import(\"web-tree-sitter/tree-sitter.wasm\" as string, {\n          with: { type: \"wasm\" },\n        })\n\n        if (isBunfsPath(treeWasm)) {\n          treeWasm = normalizeBunfsPath(path.parse(treeWasm).base)\n        }\n\n        await Parser.init({\n          locateFile() {\n            return treeWasm\n          },\n        })\n\n        this.initialized = true\n        resolve()\n      } catch (error) {\n        reject(error)\n      }\n    })\n    return this.initializePromise\n  }\n\n  public addFiletypeParser(filetypeParser: FiletypeParserOptions) {\n    this.filetypeParserOptions.set(filetypeParser.filetype, filetypeParser)\n  }\n\n  private async createQueries(\n    filetypeParser: FiletypeParserOptions,\n    language: Language,\n  ): Promise<\n    | {\n        highlights: Query\n        injections?: Query\n      }\n    | undefined\n  > {\n    try {\n      const highlightQueryContent = await this.fetchQueries(filetypeParser.queries.highlights, filetypeParser.filetype)\n      if (!highlightQueryContent) {\n        console.error(\"Failed to fetch highlight queries for:\", filetypeParser.filetype)\n        return undefined\n      }\n\n      const highlightsQuery = new Query(language, highlightQueryContent)\n      const result: { highlights: Query; injections?: Query } = {\n        highlights: highlightsQuery,\n      }\n\n      if (filetypeParser.queries.injections && filetypeParser.queries.injections.length > 0) {\n        const injectionQueryContent = await this.fetchQueries(\n          filetypeParser.queries.injections,\n          filetypeParser.filetype,\n        )\n        if (injectionQueryContent) {\n          result.injections = new Query(language, injectionQueryContent)\n        }\n      }\n\n      return result\n    } catch (error) {\n      console.error(\"Error creating queries for\", filetypeParser.filetype, filetypeParser.queries)\n      console.error(error)\n      return undefined\n    }\n  }\n\n  private async loadLanguage(languageSource: string): Promise<Language | undefined> {\n    if (!this.initialized || !this.tsDataPath) {\n      return undefined\n    }\n\n    const result = await DownloadUtils.downloadOrLoad(languageSource, this.tsDataPath, \"languages\", \".wasm\", false)\n\n    if (result.error) {\n      console.error(`Error loading language ${languageSource}:`, result.error)\n      return undefined\n    }\n\n    if (!result.filePath) {\n      return undefined\n    }\n\n    // Normalize path for Windows compatibility - tree-sitter expects forward slashes\n    const normalizedPath = result.filePath.replaceAll(\"\\\\\", \"/\")\n\n    try {\n      const language = await Language.load(normalizedPath)\n      return language\n    } catch (error) {\n      console.error(`Error loading language from ${normalizedPath}:`, error)\n      return undefined\n    }\n  }\n\n  private async resolveFiletypeParser(filetype: string): Promise<FiletypeParser | undefined> {\n    if (this.filetypeParsers.has(filetype)) {\n      return this.filetypeParsers.get(filetype)\n    }\n\n    if (this.filetypeParserPromises.has(filetype)) {\n      return this.filetypeParserPromises.get(filetype)\n    }\n\n    const loadingPromise = this.loadFiletypeParser(filetype)\n    this.filetypeParserPromises.set(filetype, loadingPromise)\n\n    try {\n      const result = await loadingPromise\n      if (result) {\n        this.filetypeParsers.set(filetype, result)\n      }\n      return result\n    } finally {\n      this.filetypeParserPromises.delete(filetype)\n    }\n  }\n\n  private async loadFiletypeParser(filetype: string): Promise<FiletypeParser | undefined> {\n    const filetypeParserOptions = this.filetypeParserOptions.get(filetype)\n    if (!filetypeParserOptions) {\n      return undefined\n    }\n    const language = await this.loadLanguage(filetypeParserOptions.wasm)\n    if (!language) {\n      return undefined\n    }\n    const queries = await this.createQueries(filetypeParserOptions, language)\n    if (!queries) {\n      console.error(\"Failed to create queries for:\", filetype)\n      return undefined\n    }\n    const filetypeParser: FiletypeParser = {\n      ...filetypeParserOptions,\n      queries,\n      language,\n    }\n    return filetypeParser\n  }\n\n  public async preloadParser(filetype: string) {\n    return this.resolveFiletypeParser(filetype)\n  }\n\n  private async getReusableParser(filetype: string): Promise<ReusableParserState | undefined> {\n    if (this.reusableParsers.has(filetype)) {\n      return this.reusableParsers.get(filetype)\n    }\n\n    if (this.reusableParserPromises.has(filetype)) {\n      return this.reusableParserPromises.get(filetype)\n    }\n\n    const creationPromise = this.createReusableParser(filetype)\n    this.reusableParserPromises.set(filetype, creationPromise)\n\n    try {\n      const result = await creationPromise\n      if (result) {\n        this.reusableParsers.set(filetype, result)\n      }\n      return result\n    } finally {\n      this.reusableParserPromises.delete(filetype)\n    }\n  }\n\n  private async createReusableParser(filetype: string): Promise<ReusableParserState | undefined> {\n    const filetypeParser = await this.resolveFiletypeParser(filetype)\n    if (!filetypeParser) {\n      return undefined\n    }\n\n    const parser = new Parser()\n    parser.setLanguage(filetypeParser.language)\n\n    const reusableState: ReusableParserState = {\n      parser,\n      filetypeParser,\n      queries: filetypeParser.queries,\n    }\n\n    return reusableState\n  }\n\n  async handleInitializeParser(\n    bufferId: number,\n    version: number,\n    content: string,\n    filetype: string,\n    messageId: string,\n  ) {\n    const filetypeParser = await this.resolveFiletypeParser(filetype)\n\n    if (!filetypeParser) {\n      self.postMessage({\n        type: \"PARSER_INIT_RESPONSE\",\n        bufferId,\n        messageId,\n        hasParser: false,\n        warning: `No parser available for filetype ${filetype}`,\n      })\n      return\n    }\n\n    const parser = new Parser()\n    parser.setLanguage(filetypeParser.language)\n    const tree = parser.parse(content)\n    if (!tree) {\n      self.postMessage({\n        type: \"PARSER_INIT_RESPONSE\",\n        bufferId,\n        messageId,\n        hasParser: false,\n        error: \"Failed to parse buffer\",\n      })\n      return\n    }\n\n    const parserState: ParserState = {\n      parser,\n      tree,\n      queries: filetypeParser.queries,\n      filetype,\n      content,\n      injectionMapping: filetypeParser.injectionMapping,\n    }\n    this.bufferParsers.set(bufferId, parserState)\n\n    self.postMessage({\n      type: \"PARSER_INIT_RESPONSE\",\n      bufferId,\n      messageId,\n      hasParser: true,\n    })\n    const highlights = await this.initialQuery(parserState)\n    self.postMessage({\n      type: \"HIGHLIGHT_RESPONSE\",\n      bufferId,\n      version,\n      ...highlights,\n    })\n  }\n\n  private async initialQuery(parserState: ParserState) {\n    const query = parserState.queries.highlights\n    const matches: QueryCapture[] = query.captures(parserState.tree.rootNode)\n    let injectionRanges = new Map<string, Array<{ start: number; end: number }>>()\n\n    if (parserState.queries.injections) {\n      const injectionResult = await this.processInjections(parserState)\n      matches.push(...injectionResult.captures)\n      injectionRanges = injectionResult.injectionRanges\n    }\n\n    return this.getHighlights(parserState, matches, injectionRanges)\n  }\n\n  private getNodeText(node: any, content: string): string {\n    return content.substring(node.startIndex, node.endIndex)\n  }\n\n  private async processInjections(\n    parserState: ParserState,\n  ): Promise<{ captures: QueryCapture[]; injectionRanges: Map<string, Array<{ start: number; end: number }>> }> {\n    const injectionMatches: QueryCapture[] = []\n    const injectionRanges = new Map<string, Array<{ start: number; end: number }>>()\n\n    if (!parserState.queries.injections) {\n      return { captures: injectionMatches, injectionRanges }\n    }\n\n    const content = parserState.content\n    const injectionCaptures = parserState.queries.injections.captures(parserState.tree.rootNode)\n    const languageGroups = new Map<string, Array<{ node: any; name: string }>>()\n\n    // Use the injection mapping stored in the parser state\n    const injectionMapping = parserState.injectionMapping\n\n    for (const capture of injectionCaptures) {\n      const captureName = capture.name\n\n      if (captureName === \"injection.content\" || captureName.includes(\"injection\")) {\n        const nodeType = capture.node.type\n        let targetLanguage: string | undefined\n\n        // First, check if there's a direct node type mapping\n        if (injectionMapping?.nodeTypes && injectionMapping.nodeTypes[nodeType]) {\n          targetLanguage = injectionMapping.nodeTypes[nodeType]\n        } else if (nodeType === \"code_fence_content\") {\n          // For code fence content, try to extract language from info_string\n          const parent = capture.node.parent\n          if (parent) {\n            const infoString = parent.children.find((child: any) => child.type === \"info_string\")\n            if (infoString) {\n              const languageNode = infoString.children.find((child: any) => child.type === \"language\")\n              if (languageNode) {\n                const languageName = this.getNodeText(languageNode, content)\n\n                if (injectionMapping?.infoStringMap && injectionMapping.infoStringMap[languageName]) {\n                  targetLanguage = injectionMapping.infoStringMap[languageName]\n                } else {\n                  targetLanguage = languageName\n                }\n              }\n            }\n          }\n        }\n\n        if (targetLanguage) {\n          if (!languageGroups.has(targetLanguage)) {\n            languageGroups.set(targetLanguage, [])\n          }\n          languageGroups.get(targetLanguage)!.push({ node: capture.node, name: capture.name })\n        }\n      }\n    }\n\n    // Process each language group\n    for (const [language, captures] of languageGroups.entries()) {\n      const injectedParser = await this.getReusableParser(language)\n\n      if (!injectedParser) {\n        console.warn(`No parser found for injection language: ${language}`)\n        continue\n      }\n\n      // Track injection ranges for this language\n      if (!injectionRanges.has(language)) {\n        injectionRanges.set(language, [])\n      }\n\n      const parser = injectedParser.parser\n      for (const { node: injectionNode } of captures) {\n        try {\n          // Record the injection range\n          injectionRanges.get(language)!.push({\n            start: injectionNode.startIndex,\n            end: injectionNode.endIndex,\n          })\n\n          const injectionContent = this.getNodeText(injectionNode, content)\n          const tree = parser.parse(injectionContent)\n\n          if (tree) {\n            const matches = injectedParser.queries.highlights.captures(tree.rootNode)\n\n            // Create new QueryCapture objects with offset positions\n            for (const match of matches) {\n              // Calculate offset positions by creating a new capture with adjusted node properties\n              // Store the injected query reference so we can look up properties correctly\n              const offsetCapture: QueryCapture & { _injectedQuery?: Query } = {\n                name: match.name,\n                patternIndex: match.patternIndex,\n                _injectedQuery: injectedParser.queries.highlights, // Store the correct query reference\n                node: {\n                  ...match.node,\n                  startPosition: {\n                    row: match.node.startPosition.row + injectionNode.startPosition.row,\n                    column:\n                      match.node.startPosition.row === 0\n                        ? match.node.startPosition.column + injectionNode.startPosition.column\n                        : match.node.startPosition.column,\n                  },\n                  endPosition: {\n                    row: match.node.endPosition.row + injectionNode.startPosition.row,\n                    column:\n                      match.node.endPosition.row === 0\n                        ? match.node.endPosition.column + injectionNode.startPosition.column\n                        : match.node.endPosition.column,\n                  },\n                  startIndex: match.node.startIndex + injectionNode.startIndex,\n                  endIndex: match.node.endIndex + injectionNode.startIndex,\n                } as any, // Cast to any since we're creating a pseudo-node\n              }\n\n              injectionMatches.push(offsetCapture)\n            }\n\n            tree.delete()\n          }\n        } catch (error) {\n          console.error(`Error processing injection for language ${language}:`, error)\n        }\n      }\n\n      // NOTE: Do NOT call parser.delete() here - this is a reusable parser!\n    }\n\n    return { captures: injectionMatches, injectionRanges }\n  }\n\n  private editToRange(edit: Edit): Range {\n    return {\n      startPosition: {\n        column: edit.startPosition.column,\n        row: edit.startPosition.row,\n      },\n      endPosition: {\n        column: edit.newEndPosition.column,\n        row: edit.newEndPosition.row,\n      },\n      startIndex: edit.startIndex,\n      endIndex: edit.newEndIndex,\n    }\n  }\n\n  async handleEdits(\n    bufferId: number,\n    content: string,\n    edits: Edit[],\n  ): Promise<{ highlights?: HighlightResponse[]; warning?: string; error?: string }> {\n    const parserState = this.bufferParsers.get(bufferId)\n    if (!parserState) {\n      return { warning: \"No parser state found for buffer\" }\n    }\n\n    parserState.content = content\n\n    for (const edit of edits) {\n      parserState.tree.edit(edit)\n    }\n\n    const startParse = performance.now()\n\n    const newTree = parserState.parser.parse(content, parserState.tree)\n\n    const endParse = performance.now()\n    const parseTime = endParse - startParse\n    this.performance.parseTimes.push(parseTime)\n    if (this.performance.parseTimes.length > 10) {\n      this.performance.parseTimes.shift()\n    }\n    this.performance.averageParseTime =\n      this.performance.parseTimes.reduce((acc, time) => acc + time, 0) / this.performance.parseTimes.length\n\n    if (!newTree) {\n      return { error: \"Failed to parse buffer\" }\n    }\n\n    const changedRanges = parserState.tree.getChangedRanges(newTree)\n    parserState.tree = newTree\n\n    const startQuery = performance.now()\n    const matches: QueryCapture[] = []\n\n    if (changedRanges.length === 0) {\n      edits.forEach((edit) => {\n        const range = this.editToRange(edit)\n        changedRanges.push(range)\n      })\n    }\n\n    for (const range of changedRanges) {\n      let node = parserState.tree.rootNode.descendantForPosition(range.startPosition, range.endPosition)\n\n      if (!node) {\n        continue\n      }\n\n      // If we got the root node, query with range to limit scope\n      if (node.equals(parserState.tree.rootNode)) {\n        // WHY ARE RANGES NOT WORKING!?\n        // The changed ranges are not returning anything in some cases\n        // Even this shit somehow returns many lines before the actual range,\n        // and even though expanded by 1000 bytes it does not capture much beyond the actual range.\n        // So freaking weird.\n        const rangeCaptures = parserState.queries.highlights.captures(\n          node,\n          // WTF!?\n          {\n            startIndex: range.startIndex - 100,\n            endIndex: range.endIndex + 1000,\n          },\n        )\n        matches.push(...rangeCaptures)\n        continue\n      }\n\n      while (node && !this.nodeContainsRange(node, range)) {\n        node = node.parent\n      }\n\n      if (!node) {\n        node = parserState.tree.rootNode\n      }\n\n      const nodeCaptures = parserState.queries.highlights.captures(node)\n      matches.push(...nodeCaptures)\n    }\n\n    let injectionRanges = new Map<string, Array<{ start: number; end: number }>>()\n    if (parserState.queries.injections) {\n      const injectionResult = await this.processInjections(parserState)\n      // Only add injection matches that are in the changed ranges\n      // This is a simplification - ideally we'd only process injections in changed ranges\n      matches.push(...injectionResult.captures)\n      injectionRanges = injectionResult.injectionRanges\n    }\n\n    const endQuery = performance.now()\n    const queryTime = endQuery - startQuery\n    this.performance.queryTimes.push(queryTime)\n    if (this.performance.queryTimes.length > 10) {\n      this.performance.queryTimes.shift()\n    }\n    this.performance.averageQueryTime =\n      this.performance.queryTimes.reduce((acc, time) => acc + time, 0) / this.performance.queryTimes.length\n\n    return this.getHighlights(parserState, matches, injectionRanges)\n  }\n\n  private nodeContainsRange(node: any, range: any): boolean {\n    return (\n      node.startPosition.row <= range.startPosition.row &&\n      node.endPosition.row >= range.endPosition.row &&\n      (node.startPosition.row < range.startPosition.row || node.startPosition.column <= range.startPosition.column) &&\n      (node.endPosition.row > range.endPosition.row || node.endPosition.column >= range.endPosition.column)\n    )\n  }\n\n  private getHighlights(\n    parserState: ParserState,\n    matches: QueryCapture[],\n    injectionRanges?: Map<string, Array<{ start: number; end: number }>>,\n  ): { highlights: HighlightResponse[] } {\n    const lineHighlights: Map<number, Map<number, HighlightRange>> = new Map()\n    const droppedHighlights: Map<number, Map<number, HighlightRange>> = new Map()\n\n    for (const match of matches) {\n      const node = match.node\n      const startLine = node.startPosition.row\n      const endLine = node.endPosition.row\n\n      const highlight = {\n        startCol: node.startPosition.column,\n        endCol: node.endPosition.column,\n        group: match.name,\n      }\n\n      if (!lineHighlights.has(startLine)) {\n        lineHighlights.set(startLine, new Map())\n        droppedHighlights.set(startLine, new Map())\n      }\n      if (lineHighlights.get(startLine)?.has(node.id)) {\n        droppedHighlights.get(startLine)?.set(node.id, lineHighlights.get(startLine)?.get(node.id)!)\n      }\n      lineHighlights.get(startLine)?.set(node.id, highlight)\n\n      if (startLine !== endLine) {\n        for (let line = startLine + 1; line <= endLine; line++) {\n          if (!lineHighlights.has(line)) {\n            lineHighlights.set(line, new Map())\n          }\n          const hl: HighlightRange = {\n            startCol: 0,\n            endCol: node.endPosition.column,\n            group: match.name,\n          }\n          lineHighlights.get(line)?.set(node.id, hl)\n        }\n      }\n    }\n\n    return {\n      highlights: Array.from(lineHighlights.entries()).map(([line, lineHighlights]) => ({\n        line,\n        highlights: Array.from(lineHighlights.values()),\n        droppedHighlights: droppedHighlights.get(line) ? Array.from(droppedHighlights.get(line)!.values()) : [],\n      })),\n    }\n  }\n\n  private getSimpleHighlights(\n    matches: QueryCapture[],\n    injectionRanges: Map<string, Array<{ start: number; end: number }>>,\n  ): SimpleHighlight[] {\n    const highlights: SimpleHighlight[] = []\n\n    const flatInjectionRanges: Array<{ start: number; end: number; lang: string }> = []\n    for (const [lang, ranges] of injectionRanges.entries()) {\n      for (const range of ranges) {\n        flatInjectionRanges.push({ ...range, lang })\n      }\n    }\n\n    for (const match of matches) {\n      const node = match.node\n\n      let isInjection = false\n      let injectionLang: string | undefined\n      let containsInjection = false\n      for (const injRange of flatInjectionRanges) {\n        if (node.startIndex >= injRange.start && node.endIndex <= injRange.end) {\n          isInjection = true\n          injectionLang = injRange.lang\n          break\n        } else if (node.startIndex <= injRange.start && node.endIndex >= injRange.end) {\n          containsInjection = true\n          break\n        }\n      }\n\n      const matchQuery = (match as any)._injectedQuery\n      const patternProperties = matchQuery?.setProperties?.[match.patternIndex]\n\n      const concealValue = patternProperties?.conceal ?? match.setProperties?.conceal\n      const concealLines = patternProperties?.conceal_lines ?? match.setProperties?.conceal_lines\n\n      const meta: any = {}\n      if (isInjection && injectionLang) {\n        meta.isInjection = true\n        meta.injectionLang = injectionLang\n      }\n      if (containsInjection) {\n        meta.containsInjection = true\n      }\n      if (concealValue !== undefined) {\n        meta.conceal = concealValue\n      }\n      if (concealLines !== undefined) {\n        meta.concealLines = concealLines\n      }\n\n      if (Object.keys(meta).length > 0) {\n        highlights.push([node.startIndex, node.endIndex, match.name, meta])\n      } else {\n        highlights.push([node.startIndex, node.endIndex, match.name])\n      }\n    }\n\n    highlights.sort((a, b) => a[0] - b[0])\n\n    return highlights\n  }\n\n  async handleResetBuffer(\n    bufferId: number,\n    version: number,\n    content: string,\n  ): Promise<{ highlights?: HighlightResponse[]; warning?: string; error?: string }> {\n    const parserState = this.bufferParsers.get(bufferId)\n    if (!parserState) {\n      return { warning: \"No parser state found for buffer\" }\n    }\n\n    parserState.content = content\n\n    const newTree = parserState.parser.parse(content)\n\n    if (!newTree) {\n      return { error: \"Failed to parse buffer during reset\" }\n    }\n\n    parserState.tree = newTree\n    const matches = parserState.queries.highlights.captures(parserState.tree.rootNode)\n\n    let injectionRanges = new Map<string, Array<{ start: number; end: number }>>()\n    if (parserState.queries.injections) {\n      const injectionResult = await this.processInjections(parserState)\n      matches.push(...injectionResult.captures)\n      injectionRanges = injectionResult.injectionRanges\n    }\n\n    return this.getHighlights(parserState, matches, injectionRanges)\n  }\n\n  disposeBuffer(bufferId: number): void {\n    const parserState = this.bufferParsers.get(bufferId)\n    if (!parserState) {\n      return\n    }\n\n    parserState.tree.delete()\n    parserState.parser.delete()\n\n    this.bufferParsers.delete(bufferId)\n  }\n\n  async handleOneShotHighlight(content: string, filetype: string, messageId: string): Promise<void> {\n    const reusableState = await this.getReusableParser(filetype)\n\n    if (!reusableState) {\n      self.postMessage({\n        type: \"ONESHOT_HIGHLIGHT_RESPONSE\",\n        messageId,\n        hasParser: false,\n        warning: `No parser available for filetype ${filetype}`,\n      })\n      return\n    }\n\n    // Markdown Parser BUG: For markdown, ensure content ends with newline so closing delimiters are parsed correctly\n    // The tree-sitter markdown parser only creates closing delimiter nodes when followed by newline\n    const parseContent = filetype === \"markdown\" && content.endsWith(\"```\") ? content + \"\\n\" : content\n\n    const tree = reusableState.parser.parse(parseContent)\n\n    if (!tree) {\n      self.postMessage({\n        type: \"ONESHOT_HIGHLIGHT_RESPONSE\",\n        messageId,\n        hasParser: false,\n        error: \"Failed to parse content\",\n      })\n      return\n    }\n\n    try {\n      const matches = reusableState.filetypeParser.queries.highlights.captures(tree.rootNode)\n\n      let injectionRanges = new Map<string, Array<{ start: number; end: number }>>()\n      if (reusableState.filetypeParser.queries.injections) {\n        const parserState: ParserState = {\n          parser: reusableState.parser,\n          tree,\n          queries: reusableState.filetypeParser.queries,\n          filetype,\n          content,\n          injectionMapping: reusableState.filetypeParser.injectionMapping,\n        }\n        const injectionResult = await this.processInjections(parserState)\n\n        matches.push(...injectionResult.captures)\n        injectionRanges = injectionResult.injectionRanges\n      }\n\n      const highlights = this.getSimpleHighlights(matches, injectionRanges)\n\n      self.postMessage({\n        type: \"ONESHOT_HIGHLIGHT_RESPONSE\",\n        messageId,\n        hasParser: true,\n        highlights,\n      })\n    } finally {\n      tree.delete()\n    }\n  }\n\n  async updateDataPath(dataPath: string): Promise<void> {\n    this.dataPath = dataPath\n    this.tsDataPath = path.join(dataPath, \"tree-sitter\")\n\n    try {\n      await mkdir(path.join(this.tsDataPath, \"languages\"), { recursive: true })\n      await mkdir(path.join(this.tsDataPath, \"queries\"), { recursive: true })\n    } catch (error) {\n      throw new Error(`Failed to update data path: ${error}`)\n    }\n  }\n\n  async clearCache(): Promise<void> {\n    if (!this.dataPath || !this.tsDataPath) {\n      throw new Error(\"No data path configured\")\n    }\n\n    const { rm } = await import(\"fs/promises\")\n\n    try {\n      const treeSitterPath = path.join(this.dataPath, \"tree-sitter\")\n\n      await rm(treeSitterPath, { recursive: true, force: true })\n\n      await mkdir(path.join(treeSitterPath, \"languages\"), { recursive: true })\n      await mkdir(path.join(treeSitterPath, \"queries\"), { recursive: true })\n\n      this.filetypeParsers.clear()\n      this.filetypeParserPromises.clear()\n      this.reusableParsers.clear()\n      this.reusableParserPromises.clear()\n    } catch (error) {\n      throw new Error(`Failed to clear cache: ${error}`)\n    }\n  }\n}\nif (!isMainThread) {\n  const worker = new ParserWorker()\n\n  function logMessage(type: \"log\" | \"error\" | \"warn\", ...args: any[]) {\n    self.postMessage({\n      type: \"WORKER_LOG\",\n      logType: type,\n      data: args,\n    })\n  }\n  console.log = (...args) => logMessage(\"log\", ...args)\n  console.error = (...args) => logMessage(\"error\", ...args)\n  console.warn = (...args) => logMessage(\"warn\", ...args)\n\n  // @ts-ignore - we'll fix this in the future for sure\n  self.onmessage = async (e: MessageEvent) => {\n    const { type, bufferId, version, content, filetype, edits, filetypeParser, messageId, dataPath } = e.data\n\n    try {\n      switch (type) {\n        case \"INIT\":\n          try {\n            await worker.initialize({ dataPath })\n            self.postMessage({ type: \"INIT_RESPONSE\" })\n          } catch (error) {\n            self.postMessage({\n              type: \"INIT_RESPONSE\",\n              error: error instanceof Error ? error.stack || error.message : String(error),\n            })\n          }\n          break\n\n        case \"ADD_FILETYPE_PARSER\":\n          worker.addFiletypeParser(filetypeParser)\n          break\n\n        case \"PRELOAD_PARSER\":\n          const maybeParser = await worker.preloadParser(filetype)\n          self.postMessage({ type: \"PRELOAD_PARSER_RESPONSE\", messageId, hasParser: !!maybeParser })\n          break\n\n        case \"INITIALIZE_PARSER\":\n          await worker.handleInitializeParser(bufferId, version, content, filetype, messageId)\n          break\n\n        case \"HANDLE_EDITS\":\n          const response = await worker.handleEdits(bufferId, content, edits)\n          if (response.highlights && response.highlights.length > 0) {\n            self.postMessage({ type: \"HIGHLIGHT_RESPONSE\", bufferId, version, ...response })\n          } else if (response.warning) {\n            self.postMessage({ type: \"WARNING\", bufferId, warning: response.warning })\n          } else if (response.error) {\n            self.postMessage({ type: \"ERROR\", bufferId, error: response.error })\n          }\n          break\n\n        case \"GET_PERFORMANCE\":\n          self.postMessage({ type: \"PERFORMANCE_RESPONSE\", performance: worker.performance, messageId })\n          break\n\n        case \"RESET_BUFFER\":\n          const resetResponse = await worker.handleResetBuffer(bufferId, version, content)\n          if (resetResponse.highlights && resetResponse.highlights.length > 0) {\n            self.postMessage({ type: \"HIGHLIGHT_RESPONSE\", bufferId, version, ...resetResponse })\n          } else if (resetResponse.warning) {\n            self.postMessage({ type: \"WARNING\", bufferId, warning: resetResponse.warning })\n          } else if (resetResponse.error) {\n            self.postMessage({ type: \"ERROR\", bufferId, error: resetResponse.error })\n          }\n          break\n\n        case \"DISPOSE_BUFFER\":\n          worker.disposeBuffer(bufferId)\n          self.postMessage({ type: \"BUFFER_DISPOSED\", bufferId })\n          break\n\n        case \"ONESHOT_HIGHLIGHT\":\n          await worker.handleOneShotHighlight(content, filetype, messageId)\n          break\n\n        case \"UPDATE_DATA_PATH\":\n          try {\n            await worker.updateDataPath(dataPath)\n            self.postMessage({ type: \"UPDATE_DATA_PATH_RESPONSE\", messageId })\n          } catch (error) {\n            self.postMessage({\n              type: \"UPDATE_DATA_PATH_RESPONSE\",\n              messageId,\n              error: error instanceof Error ? error.message : String(error),\n            })\n          }\n          break\n\n        case \"CLEAR_CACHE\":\n          try {\n            await worker.clearCache()\n            self.postMessage({ type: \"CLEAR_CACHE_RESPONSE\", messageId })\n          } catch (error) {\n            self.postMessage({\n              type: \"CLEAR_CACHE_RESPONSE\",\n              messageId,\n              error: error instanceof Error ? error.message : String(error),\n            })\n          }\n          break\n\n        default:\n          self.postMessage({\n            type: \"ERROR\",\n            bufferId,\n            error: `Unknown message type: ${type}`,\n          })\n      }\n    } catch (error) {\n      self.postMessage({\n        type: \"ERROR\",\n        bufferId,\n        error: error instanceof Error ? error.stack || error.message : String(error),\n      })\n    }\n  }\n}\n",
    "import { mkdir, writeFile } from \"fs/promises\"\nimport * as path from \"path\"\n\nexport interface DownloadResult {\n  content?: ArrayBuffer\n  filePath?: string\n  error?: string\n}\n\nexport class DownloadUtils {\n  private static hashUrl(url: string): string {\n    let hash = 0\n    for (let i = 0; i < url.length; i++) {\n      const char = url.charCodeAt(i)\n      hash = (hash << 5) - hash + char\n      hash = hash & hash\n    }\n    return Math.abs(hash).toString(16)\n  }\n\n  /**\n   * Download a file from URL or load from local path, with caching support\n   */\n  static async downloadOrLoad(\n    source: string,\n    cacheDir: string,\n    cacheSubdir: string,\n    fileExtension: string,\n    useHashForCache: boolean = true,\n    filetype?: string,\n  ): Promise<DownloadResult> {\n    const isUrl = source.startsWith(\"http://\") || source.startsWith(\"https://\")\n\n    if (isUrl) {\n      let cacheFileName: string\n      if (useHashForCache) {\n        const hash = this.hashUrl(source)\n        cacheFileName = filetype ? `${filetype}-${hash}${fileExtension}` : `${hash}${fileExtension}`\n      } else {\n        cacheFileName = path.basename(source)\n      }\n      const cacheFile = path.join(cacheDir, cacheSubdir, cacheFileName)\n\n      // Ensure cache directory exists\n      await mkdir(path.dirname(cacheFile), { recursive: true })\n\n      try {\n        const cachedContent = await Bun.file(cacheFile).arrayBuffer()\n        if (cachedContent.byteLength > 0) {\n          console.log(`Loaded from cache: ${cacheFile} (${source})`)\n          return { content: cachedContent, filePath: cacheFile }\n        }\n      } catch (error) {\n        // Cache miss, continue to fetch\n      }\n\n      try {\n        console.log(`Downloading from URL: ${source}`)\n        const response = await fetch(source)\n        if (!response.ok) {\n          return { error: `Failed to fetch from ${source}: ${response.statusText}` }\n        }\n        const content = await response.arrayBuffer()\n\n        try {\n          await writeFile(cacheFile, Buffer.from(content))\n          console.log(`Cached: ${source}`)\n        } catch (cacheError) {\n          console.warn(`Failed to cache: ${cacheError}`)\n        }\n\n        return { content, filePath: cacheFile }\n      } catch (error) {\n        return { error: `Error downloading from ${source}: ${error}` }\n      }\n    } else {\n      try {\n        console.log(`Loading from local path: ${source}`)\n        const content = await Bun.file(source).arrayBuffer()\n        return { content, filePath: source }\n      } catch (error) {\n        return { error: `Error loading from local path ${source}: ${error}` }\n      }\n    }\n  }\n\n  /**\n   * Download and save a file to a specific target path\n   */\n  static async downloadToPath(source: string, targetPath: string): Promise<DownloadResult> {\n    const isUrl = source.startsWith(\"http://\") || source.startsWith(\"https://\")\n\n    await mkdir(path.dirname(targetPath), { recursive: true })\n\n    if (isUrl) {\n      try {\n        console.log(`Downloading from URL: ${source}`)\n        const response = await fetch(source)\n        if (!response.ok) {\n          return { error: `Failed to fetch from ${source}: ${response.statusText}` }\n        }\n        const content = await response.arrayBuffer()\n\n        await writeFile(targetPath, Buffer.from(content))\n        console.log(`Downloaded: ${source} -> ${targetPath}`)\n\n        return { content, filePath: targetPath }\n      } catch (error) {\n        return { error: `Error downloading from ${source}: ${error}` }\n      }\n    } else {\n      try {\n        console.log(`Copying from local path: ${source}`)\n        const content = await Bun.file(source).arrayBuffer()\n        await writeFile(targetPath, Buffer.from(content))\n        return { content, filePath: targetPath }\n      } catch (error) {\n        return { error: `Error copying from local path ${source}: ${error}` }\n      }\n    }\n  }\n\n  /**\n   * Fetch multiple highlight queries and concatenate them\n   */\n  static async fetchHighlightQueries(sources: string[], cacheDir: string, filetype: string): Promise<string> {\n    const queryPromises = sources.map((source) => this.fetchHighlightQuery(source, cacheDir, filetype))\n    const queryResults = await Promise.all(queryPromises)\n\n    const validQueries = queryResults.filter((query) => query.trim().length > 0)\n    return validQueries.join(\"\\n\")\n  }\n\n  private static async fetchHighlightQuery(source: string, cacheDir: string, filetype: string): Promise<string> {\n    const result = await this.downloadOrLoad(source, cacheDir, \"queries\", \".scm\", true, filetype)\n\n    if (result.error) {\n      console.error(`Error fetching highlight query from ${source}:`, result.error)\n      return \"\"\n    }\n\n    if (result.content) {\n      return new TextDecoder().decode(result.content)\n    }\n\n    return \"\"\n  }\n}\n",
    "import { basename, join } from \"node:path\"\n\nexport function isBunfsPath(path: string): boolean {\n  // Removed ambiguous '//' check\n  return path.includes(\"$bunfs\") || /^B:[\\\\/]~BUN/i.test(path)\n}\n\nexport function getBunfsRootPath(): string {\n  return process.platform === \"win32\" ? \"B:\\\\~BUN\\\\root\" : \"/$bunfs/root\"\n}\n\n/**\n * Normalizes a path to the embedded root.\n * Flattens directory structure to ensure file exists at root.\n */\nexport function normalizeBunfsPath(fileName: string): string {\n  return join(getBunfsRootPath(), basename(fileName))\n}\n"
  ],
  "mappings": "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",
  "debugId": "A12A2CF1481F706164756E2164756E21",
  "names": []
}
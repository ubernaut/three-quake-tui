{
  "version": 3,
  "sources": ["../src/testing/test-renderer.ts", "../src/testing/mock-keys.ts", "../src/testing/mock-mouse.ts", "../src/testing/mock-tree-sitter-client.ts", "../src/testing/spy.ts", "../src/testing/test-recorder.ts"],
  "sourcesContent": [
    "import { Readable } from \"stream\"\nimport { CliRenderer, type CliRendererConfig } from \"../renderer\"\nimport { resolveRenderLib } from \"../zig\"\nimport { createMockKeys } from \"./mock-keys\"\nimport { createMockMouse } from \"./mock-mouse\"\nimport type { CapturedFrame } from \"../types\"\n\nexport interface TestRendererOptions extends CliRendererConfig {\n  width?: number\n  height?: number\n  kittyKeyboard?: boolean\n  otherModifiersMode?: boolean\n}\nexport interface TestRenderer extends CliRenderer {}\nexport type MockInput = ReturnType<typeof createMockKeys>\nexport type MockMouse = ReturnType<typeof createMockMouse>\n\nconst decoder = new TextDecoder()\n\nexport async function createTestRenderer(options: TestRendererOptions): Promise<{\n  renderer: TestRenderer\n  mockInput: MockInput\n  mockMouse: MockMouse\n  renderOnce: () => Promise<void>\n  captureCharFrame: () => string\n  captureSpans: () => CapturedFrame\n  resize: (width: number, height: number) => void\n}> {\n  process.env.OTUI_USE_CONSOLE = \"false\"\n\n  // Convert legacy kittyKeyboard boolean to new format\n  const useKittyKeyboard = options.kittyKeyboard ? { events: true } : options.useKittyKeyboard\n\n  const renderer = await setupTestRenderer({\n    ...options,\n    useKittyKeyboard,\n    useAlternateScreen: false,\n    useConsole: false,\n  })\n\n  renderer.disableStdoutInterception()\n\n  const mockInput = createMockKeys(renderer, {\n    kittyKeyboard: options.kittyKeyboard,\n    otherModifiersMode: options.otherModifiersMode,\n  })\n  const mockMouse = createMockMouse(renderer)\n\n  const renderOnce = async () => {\n    //@ts-expect-error - this is a test renderer\n    await renderer.loop()\n  }\n\n  return {\n    renderer,\n    mockInput,\n    mockMouse,\n    renderOnce,\n    captureCharFrame: () => {\n      const currentBuffer = renderer.currentRenderBuffer\n      const frameBytes = currentBuffer.getRealCharBytes(true)\n      return decoder.decode(frameBytes)\n    },\n    captureSpans: () => {\n      const currentBuffer = renderer.currentRenderBuffer\n      const lines = currentBuffer.getSpanLines()\n      const cursorState = renderer.getCursorState()\n      return {\n        cols: currentBuffer.width,\n        rows: currentBuffer.height,\n        cursor: [cursorState.x, cursorState.y] as [number, number],\n        lines,\n      }\n    },\n    resize: (width: number, height: number) => {\n      //@ts-expect-error - this is a test renderer\n      renderer.processResize(width, height)\n    },\n  }\n}\n\nasync function setupTestRenderer(config: TestRendererOptions) {\n  const stdin = config.stdin || (new Readable({ read() {} }) as NodeJS.ReadStream)\n  const stdout = config.stdout || process.stdout\n\n  const width = config.width || stdout.columns || 80\n  const height = config.height || stdout.rows || 24\n  const renderHeight =\n    config.experimental_splitHeight && config.experimental_splitHeight > 0 ? config.experimental_splitHeight : height\n\n  const ziglib = resolveRenderLib()\n  const rendererPtr = ziglib.createRenderer(width, renderHeight, {\n    testing: true,\n    remote: config.remote ?? false,\n  })\n  if (!rendererPtr) {\n    throw new Error(\"Failed to create test renderer\")\n  }\n  if (config.useThread === undefined) {\n    config.useThread = true\n  }\n\n  if (process.platform === \"linux\") {\n    config.useThread = false\n  }\n  ziglib.setUseThread(rendererPtr, config.useThread)\n\n  const renderer = new CliRenderer(ziglib, rendererPtr, stdin, stdout, width, height, config)\n\n  process.off(\"SIGWINCH\", renderer[\"sigwinchHandler\"])\n\n  // Do not setup the terminal for testing as we will not actually output anything to the terminal\n  // await renderer.setupTerminal()\n\n  return renderer\n}\n",
    "import type { CliRenderer } from \"../renderer\"\nimport { ANSI } from \"../ansi\"\n\nexport const KeyCodes = {\n  // Control keys\n  RETURN: \"\\r\",\n  LINEFEED: \"\\n\",\n  TAB: \"\\t\",\n  BACKSPACE: \"\\b\",\n  // NOTE: This may depend on the platform and terminals\n  DELETE: \"\\x1b[3~\",\n  HOME: \"\\x1b[H\",\n  END: \"\\x1b[F\",\n  ESCAPE: \"\\x1b\",\n\n  // Arrow keys\n  ARROW_UP: \"\\x1b[A\",\n  ARROW_DOWN: \"\\x1b[B\",\n  ARROW_RIGHT: \"\\x1b[C\",\n  ARROW_LEFT: \"\\x1b[D\",\n\n  // Function keys\n  F1: \"\\x1bOP\",\n  F2: \"\\x1bOQ\",\n  F3: \"\\x1bOR\",\n  F4: \"\\x1bOS\",\n  F5: \"\\x1b[15~\",\n  F6: \"\\x1b[17~\",\n  F7: \"\\x1b[18~\",\n  F8: \"\\x1b[19~\",\n  F9: \"\\x1b[20~\",\n  F10: \"\\x1b[21~\",\n  F11: \"\\x1b[23~\",\n  F12: \"\\x1b[24~\",\n} as const\n\nexport type KeyInput = string | keyof typeof KeyCodes\n\nexport interface MockKeysOptions {\n  kittyKeyboard?: boolean\n  otherModifiersMode?: boolean\n}\n\n// Kitty keyboard protocol key mappings\nconst kittyKeyCodeMap: Record<string, number> = {\n  escape: 27,\n  tab: 9,\n  return: 13,\n  backspace: 127,\n  insert: 57348,\n  delete: 57349,\n  left: 57350,\n  right: 57351,\n  up: 57352,\n  down: 57353,\n  pageup: 57354,\n  pagedown: 57355,\n  home: 57356,\n  end: 57357,\n  f1: 57364,\n  f2: 57365,\n  f3: 57366,\n  f4: 57367,\n  f5: 57368,\n  f6: 57369,\n  f7: 57370,\n  f8: 57371,\n  f9: 57372,\n  f10: 57373,\n  f11: 57374,\n  f12: 57375,\n}\n\nfunction encodeKittySequence(\n  codepoint: number,\n  modifiers?: { shift?: boolean; ctrl?: boolean; meta?: boolean; super?: boolean; hyper?: boolean },\n): string {\n  // Kitty keyboard protocol: CSI unicode-key-code ; modifiers u\n  // Modifier encoding: shift=1, alt=2, ctrl=4, super=8, hyper=16, meta=32, caps=64, num=128\n  let modMask = 0\n  if (modifiers?.shift) modMask |= 1\n  if (modifiers?.meta) modMask |= 2 // alt/meta\n  if (modifiers?.ctrl) modMask |= 4\n  if (modifiers?.super) modMask |= 8\n  if (modifiers?.hyper) modMask |= 16\n\n  if (modMask === 0) {\n    // No modifiers\n    return `\\x1b[${codepoint}u`\n  } else {\n    // With modifiers (kitty uses 1-based, so add 1)\n    return `\\x1b[${codepoint};${modMask + 1}u`\n  }\n}\n\nfunction encodeModifyOtherKeysSequence(\n  charCode: number,\n  modifiers?: { shift?: boolean; ctrl?: boolean; meta?: boolean; super?: boolean; hyper?: boolean },\n): string {\n  // modifyOtherKeys protocol: CSI 27 ; modifier ; code ~\n  // This is the format used by xterm, iTerm2, Ghostty with modifyOtherKeys enabled\n  // Modifier encoding: shift=1, alt/option=2, ctrl=4, super=8, hyper=16 (1-based, so add 1)\n  let modMask = 0\n  if (modifiers?.shift) modMask |= 1\n  if (modifiers?.meta) modMask |= 2 // alt/option/meta\n  if (modifiers?.ctrl) modMask |= 4\n  if (modifiers?.super) modMask |= 8\n  if (modifiers?.hyper) modMask |= 16\n\n  // modifyOtherKeys is only used when modifiers are present\n  // Without modifiers, use the standard key sequence\n  if (modMask === 0) {\n    return String.fromCharCode(charCode)\n  }\n\n  // With modifiers, use CSI 27 ; modifier ; code ~\n  return `\\x1b[27;${modMask + 1};${charCode}~`\n}\n\ninterface ResolvedKey {\n  keyValue: string\n  keyName: string | undefined\n}\n\nfunction resolveKeyInput(key: KeyInput): ResolvedKey {\n  let keyValue: string\n  let keyName: string | undefined\n\n  if (typeof key === \"string\") {\n    if (key in KeyCodes) {\n      // It's a KeyCode name like \"BACKSPACE\", \"ARROW_UP\", etc.\n      keyValue = KeyCodes[key as keyof typeof KeyCodes]\n      keyName = key.toLowerCase()\n    } else {\n      // It's a regular character\n      keyValue = key\n      keyName = undefined\n    }\n  } else {\n    // It's already a keycode enum value\n    keyValue = KeyCodes[key]\n    if (!keyValue) {\n      throw new Error(`Unknown key: ${key}`)\n    }\n    keyName = String(key).toLowerCase()\n  }\n\n  return { keyValue, keyName }\n}\n\nexport function createMockKeys(renderer: CliRenderer, options?: MockKeysOptions) {\n  const useKittyKeyboard = options?.kittyKeyboard ?? false\n  const useOtherModifiersMode = options?.otherModifiersMode ?? false\n\n  // Kitty keyboard takes precedence over otherModifiersMode\n  const effectiveOtherModifiersMode = useOtherModifiersMode && !useKittyKeyboard\n\n  const pressKeys = async (keys: KeyInput[], delayMs: number = 0): Promise<void> => {\n    for (const key of keys) {\n      const { keyValue: keyCode } = resolveKeyInput(key)\n\n      renderer.stdin.emit(\"data\", Buffer.from(keyCode))\n\n      if (delayMs > 0) {\n        await new Promise((resolve) => setTimeout(resolve, delayMs))\n      }\n    }\n  }\n\n  const pressKey = (\n    key: KeyInput,\n    modifiers?: { shift?: boolean; ctrl?: boolean; meta?: boolean; super?: boolean; hyper?: boolean },\n  ): void => {\n    // Handle Kitty keyboard protocol mode\n    if (useKittyKeyboard) {\n      // Resolve the key to its string representation or keycode value\n      let { keyValue, keyName } = resolveKeyInput(key)\n\n      // Map control characters and escape sequences to their kitty key names\n      const valueToKeyNameMap: Record<string, string> = {\n        \"\\b\": \"backspace\",\n        \"\\r\": \"return\",\n        \"\\n\": \"return\",\n        \"\\t\": \"tab\",\n        \"\\x1b\": \"escape\",\n        \"\\x1b[A\": \"up\",\n        \"\\x1b[B\": \"down\",\n        \"\\x1b[C\": \"right\",\n        \"\\x1b[D\": \"left\",\n        \"\\x1b[H\": \"home\",\n        \"\\x1b[F\": \"end\",\n        \"\\x1b[3~\": \"delete\",\n      }\n\n      // Check value mapping\n      if (keyValue && valueToKeyNameMap[keyValue]) {\n        keyName = valueToKeyNameMap[keyValue]\n      }\n\n      // Also check for ARROW_ prefix\n      if (keyName && keyName.startsWith(\"arrow_\")) {\n        keyName = keyName.substring(6) // Remove \"arrow_\" prefix\n      }\n\n      // Check if we have a direct kitty code mapping\n      if (keyName && kittyKeyCodeMap[keyName]) {\n        const kittyCode = kittyKeyCodeMap[keyName]\n        const sequence = encodeKittySequence(kittyCode, modifiers)\n        renderer.stdin.emit(\"data\", Buffer.from(sequence))\n        return\n      }\n\n      // For regular characters, get the codepoint\n      if (keyValue && keyValue.length === 1 && !keyValue.startsWith(\"\\x1b\")) {\n        const codepoint = keyValue.codePointAt(0)\n        if (codepoint) {\n          const sequence = encodeKittySequence(codepoint, modifiers)\n          renderer.stdin.emit(\"data\", Buffer.from(sequence))\n          return\n        }\n      }\n\n      // Fall through to regular mode for unknown keys\n    }\n\n    // Handle modifyOtherKeys mode (CSI u protocol variant)\n    // Used by xterm, iTerm2, Ghostty with modifyOtherKeys enabled\n    if (effectiveOtherModifiersMode && modifiers) {\n      // Resolve the key to its string representation or keycode value\n      let { keyValue, keyName } = resolveKeyInput(key)\n\n      // Map control characters and escape sequences to their char codes\n      const valueToCharCodeMap: Record<string, number> = {\n        \"\\b\": 127, // backspace (or 8, but 127 is more common)\n        \"\\r\": 13, // return\n        \"\\n\": 13, // linefeed -> return\n        \"\\t\": 9, // tab\n        \"\\x1b\": 27, // escape\n        \" \": 32, // space\n      }\n\n      // Check if we have a control character that needs modifyOtherKeys encoding\n      let charCode: number | undefined\n\n      if (keyValue && valueToCharCodeMap[keyValue] !== undefined) {\n        charCode = valueToCharCodeMap[keyValue]\n      } else if (keyValue && keyValue.length === 1 && !keyValue.startsWith(\"\\x1b\")) {\n        // For regular single characters\n        charCode = keyValue.charCodeAt(0)\n      }\n\n      // If we have a char code and modifiers, use modifyOtherKeys format\n      if (charCode !== undefined) {\n        const sequence = encodeModifyOtherKeysSequence(charCode, modifiers)\n        renderer.stdin.emit(\"data\", Buffer.from(sequence))\n        return\n      }\n\n      // For other keys (like arrow keys with modifiers), fall through to regular mode\n    }\n\n    // Regular (non-Kitty, non-modifyOtherKeys) mode\n    let keyCode = resolveKeyInput(key).keyValue\n\n    // Apply modifiers if present\n    if (modifiers) {\n      // For arrow keys and special keys, modify the escape sequence\n      if (keyCode.startsWith(\"\\x1b[\") && keyCode.length > 2) {\n        // Arrow keys: \\x1b[A, \\x1b[B, \\x1b[C, \\x1b[D\n        // With shift modifier: \\x1b[1;2A, \\x1b[1;2B, \\x1b[1;2C, \\x1b[1;2D\n        // Special keys like delete: \\x1b[3~ becomes \\x1b[3;2~ with meta\n        const modifier =\n          1 +\n          (modifiers.shift ? 1 : 0) +\n          (modifiers.meta ? 2 : 0) +\n          (modifiers.ctrl ? 4 : 0) +\n          (modifiers.super ? 8 : 0) +\n          (modifiers.hyper ? 16 : 0)\n        if (modifier > 1) {\n          // Check if it's a sequence like \\x1b[3~ (delete, insert, pageup, etc.)\n          const tildeMatch = keyCode.match(/^\\x1b\\[(\\d+)~$/)\n          if (tildeMatch) {\n            // Format: \\x1b[number;modifier~\n            keyCode = `\\x1b[${tildeMatch[1]};${modifier}~`\n          } else {\n            // Arrow keys and other single-letter endings\n            // Insert modifier into sequence\n            const ending = keyCode.slice(-1)\n            keyCode = `\\x1b[1;${modifier}${ending}`\n          }\n        }\n      } else if (keyCode.length === 1) {\n        // For regular characters and single-char control codes with modifiers\n        let char = keyCode\n\n        // Special handling for backspace with modifiers - use modifyOtherKeys format\n        // Terminals send Ctrl+Backspace as CSI 27;5;127~ (or CSI 27;5;8~)\n        // Only use modifyOtherKeys for ctrl, super, or hyper (not shift or meta alone)\n        if (char === \"\\b\" && (modifiers.ctrl || modifiers.super || modifiers.hyper)) {\n          const modifier =\n            1 +\n            (modifiers.shift ? 1 : 0) +\n            (modifiers.meta ? 2 : 0) +\n            (modifiers.ctrl ? 4 : 0) +\n            (modifiers.super ? 8 : 0) +\n            (modifiers.hyper ? 16 : 0)\n          // Use charcode 127 for backspace (DEL)\n          keyCode = `\\x1b[27;${modifier};127~`\n        } else if (modifiers.ctrl) {\n          // Handle ctrl modifier for characters\n          // Ctrl+letter produces control codes (0x01-0x1a for a-z)\n          if (char >= \"a\" && char <= \"z\") {\n            keyCode = String.fromCharCode(char.charCodeAt(0) - 96)\n          } else if (char >= \"A\" && char <= \"Z\") {\n            keyCode = String.fromCharCode(char.charCodeAt(0) - 64)\n          } else {\n            // Handle special characters with ctrl modifier\n            // These produce ASCII control codes\n            const specialCtrlMap: Record<string, string> = {\n              \"[\": \"\\x1b\", // Ctrl+[ = ESC (ASCII 27)\n              \"\\\\\": \"\\x1c\", // Ctrl+\\ = FS (ASCII 28)\n              \"]\": \"\\x1d\", // Ctrl+] = GS (ASCII 29)\n              \"^\": \"\\x1e\", // Ctrl+^ = RS (ASCII 30)\n              _: \"\\x1f\", // Ctrl+_ = US (ASCII 31)\n              \"?\": \"\\x7f\", // Ctrl+? = DEL (ASCII 127)\n              // Common aliases\n              \"/\": \"\\x1f\", // Ctrl+/ = US (ASCII 31, same as Ctrl+_)\n              \"-\": \"\\x1f\", // Ctrl+- = US (ASCII 31, same as Ctrl+_)\n              \".\": \"\\x1e\", // Ctrl+. = RS (ASCII 30, same as Ctrl+^)\n              \",\": \"\\x1c\", // Ctrl+, = FS (ASCII 28, same as Ctrl+\\)\n              \"@\": \"\\x00\", // Ctrl+@ = NUL (ASCII 0)\n              \" \": \"\\x00\", // Ctrl+Space = NUL (ASCII 0)\n            }\n\n            if (char in specialCtrlMap) {\n              keyCode = specialCtrlMap[char]\n            }\n            // If no mapping found, keep the original character\n          }\n          // If meta is also pressed, prefix with escape\n          if (modifiers.meta) {\n            keyCode = `\\x1b${keyCode}`\n          }\n        } else {\n          // Handle shift+meta or just meta\n          if (modifiers.shift && char >= \"a\" && char <= \"z\") {\n            char = char.toUpperCase()\n          }\n          if (modifiers.meta) {\n            // For meta+character (including control codes), prefix with escape\n            keyCode = `\\x1b${char}`\n          } else {\n            keyCode = char\n          }\n        }\n      } else if (modifiers.meta && !keyCode.startsWith(\"\\x1b\")) {\n        // For multi-char sequences that aren't escape sequences (like simple control codes)\n        // just prefix with escape for meta\n        keyCode = `\\x1b${keyCode}`\n      }\n    }\n\n    renderer.stdin.emit(\"data\", Buffer.from(keyCode))\n  }\n\n  const typeText = async (text: string, delayMs: number = 0): Promise<void> => {\n    const keys = text.split(\"\")\n    await pressKeys(keys, delayMs)\n  }\n\n  const pressReturn = (modifiers?: {\n    shift?: boolean\n    ctrl?: boolean\n    meta?: boolean\n    super?: boolean\n    hyper?: boolean\n  }): void => {\n    pressKey(KeyCodes.RETURN, modifiers)\n  }\n\n  const pressEscape = (modifiers?: {\n    shift?: boolean\n    ctrl?: boolean\n    meta?: boolean\n    super?: boolean\n    hyper?: boolean\n  }): void => {\n    pressKey(KeyCodes.ESCAPE, modifiers)\n  }\n\n  const pressTab = (modifiers?: {\n    shift?: boolean\n    ctrl?: boolean\n    meta?: boolean\n    super?: boolean\n    hyper?: boolean\n  }): void => {\n    pressKey(KeyCodes.TAB, modifiers)\n  }\n\n  const pressBackspace = (modifiers?: {\n    shift?: boolean\n    ctrl?: boolean\n    meta?: boolean\n    super?: boolean\n    hyper?: boolean\n  }): void => {\n    pressKey(KeyCodes.BACKSPACE, modifiers)\n  }\n\n  const pressArrow = (\n    direction: \"up\" | \"down\" | \"left\" | \"right\",\n    modifiers?: { shift?: boolean; ctrl?: boolean; meta?: boolean; super?: boolean; hyper?: boolean },\n  ): void => {\n    const keyMap = {\n      up: KeyCodes.ARROW_UP,\n      down: KeyCodes.ARROW_DOWN,\n      left: KeyCodes.ARROW_LEFT,\n      right: KeyCodes.ARROW_RIGHT,\n    }\n    pressKey(keyMap[direction], modifiers)\n  }\n\n  const pressCtrlC = (): void => {\n    pressKey(\"c\", { ctrl: true })\n  }\n\n  const pasteBracketedText = (text: string): Promise<void> => {\n    return pressKeys([ANSI.bracketedPasteStart, text, ANSI.bracketedPasteEnd])\n  }\n\n  return {\n    pressKeys,\n    pressKey,\n    typeText,\n    pressEnter: pressReturn,\n    pressEscape,\n    pressTab,\n    pressBackspace,\n    pressArrow,\n    pressCtrlC,\n    pasteBracketedText,\n  }\n}\n",
    "import type { CliRenderer } from \"../renderer\"\n\nexport const MouseButtons = {\n  LEFT: 0,\n  MIDDLE: 1,\n  RIGHT: 2,\n\n  WHEEL_UP: 64, // 64 = scroll flag + 0\n  WHEEL_DOWN: 65, // 64 + 1\n  WHEEL_LEFT: 66, // 64 + 2\n  WHEEL_RIGHT: 67, // 64 + 3\n} as const\n\nexport type MouseButton = (typeof MouseButtons)[keyof typeof MouseButtons]\n\nexport interface MousePosition {\n  x: number\n  y: number\n}\n\nexport interface MouseModifiers {\n  shift?: boolean\n  alt?: boolean\n  ctrl?: boolean\n}\n\nexport type MouseEventType = \"down\" | \"up\" | \"move\" | \"drag\" | \"scroll\"\n\nexport interface MouseEventOptions {\n  button?: MouseButton\n  modifiers?: MouseModifiers\n  delayMs?: number\n}\n\nexport function createMockMouse(renderer: CliRenderer) {\n  let currentPosition: MousePosition = { x: 0, y: 0 }\n  let buttonsPressed = new Set<MouseButton>()\n\n  // Generate SGR mouse event sequence\n  const generateMouseEvent = (\n    type: MouseEventType,\n    x: number,\n    y: number,\n    button: MouseButton = MouseButtons.LEFT,\n    modifiers: MouseModifiers = {},\n  ): string => {\n    // SGR format: \\x1b[<b;x;yM or \\x1b[<b;x;ym\n    // where b = button code + modifier flags + motion/scroll flags\n\n    let buttonCode: number = button\n\n    // Add modifier flags\n    if (modifiers.shift) buttonCode |= 4\n    if (modifiers.alt) buttonCode |= 8\n    if (modifiers.ctrl) buttonCode |= 16\n\n    switch (type) {\n      case \"move\":\n        buttonCode = 32 | 3 // motion flag (32) + button 3 for motion without button press\n        if (modifiers.shift) buttonCode |= 4\n        if (modifiers.alt) buttonCode |= 8\n        if (modifiers.ctrl) buttonCode |= 16\n        break\n      case \"drag\":\n        buttonCode = (buttonsPressed.size > 0 ? Array.from(buttonsPressed)[0] : button) | 32\n        if (modifiers.shift) buttonCode |= 4\n        if (modifiers.alt) buttonCode |= 8\n        if (modifiers.ctrl) buttonCode |= 16\n        break\n      case \"scroll\":\n        // Scroll events already have the scroll flag set in the button code\n        break\n    }\n\n    // Convert to 1-based coordinates for ANSI\n    const ansiX = x + 1\n    const ansiY = y + 1\n\n    let pressRelease = \"M\" // Default to press\n    if (type === \"up\" || type === \"move\" || type === \"drag\") {\n      pressRelease = \"m\"\n    }\n\n    return `\\x1b[<${buttonCode};${ansiX};${ansiY}${pressRelease}`\n  }\n\n  const emitMouseEvent = async (\n    type: MouseEventType,\n    x: number,\n    y: number,\n    button: MouseButton = MouseButtons.LEFT,\n    options: Omit<MouseEventOptions, \"button\"> = {},\n  ): Promise<void> => {\n    const { modifiers = {}, delayMs = 0 } = options\n\n    const eventSequence = generateMouseEvent(type, x, y, button, modifiers)\n    renderer.stdin.emit(\"data\", Buffer.from(eventSequence))\n\n    currentPosition = { x, y }\n\n    if (type === \"down\" && button < 64) {\n      buttonsPressed.add(button)\n    } else if (type === \"up\") {\n      buttonsPressed.delete(button)\n    }\n\n    if (delayMs > 0) {\n      await new Promise((resolve) => setTimeout(resolve, delayMs))\n    }\n  }\n\n  const moveTo = async (x: number, y: number, options: MouseEventOptions = {}): Promise<void> => {\n    const { button = MouseButtons.LEFT, delayMs = 0, modifiers = {} } = options\n\n    if (buttonsPressed.size > 0) {\n      await emitMouseEvent(\"drag\", x, y, Array.from(buttonsPressed)[0], { modifiers, delayMs })\n    } else {\n      await emitMouseEvent(\"move\", x, y, button, { modifiers, delayMs })\n    }\n\n    currentPosition = { x, y }\n  }\n\n  const click = async (\n    x: number,\n    y: number,\n    button: MouseButton = MouseButtons.LEFT,\n    options: MouseEventOptions = {},\n  ): Promise<void> => {\n    const { delayMs = 10, modifiers = {} } = options\n\n    await emitMouseEvent(\"down\", x, y, button, { modifiers, delayMs })\n    await new Promise((resolve) => setTimeout(resolve, delayMs))\n    await emitMouseEvent(\"up\", x, y, button, { modifiers, delayMs })\n  }\n\n  const doubleClick = async (\n    x: number,\n    y: number,\n    button: MouseButton = MouseButtons.LEFT,\n    options: MouseEventOptions = {},\n  ): Promise<void> => {\n    const { delayMs = 10, modifiers = {} } = options\n\n    await click(x, y, button, { modifiers, delayMs })\n    await new Promise((resolve) => setTimeout(resolve, delayMs))\n    await click(x, y, button, { modifiers, delayMs })\n  }\n\n  const pressDown = async (\n    x: number,\n    y: number,\n    button: MouseButton = MouseButtons.LEFT,\n    options: MouseEventOptions = {},\n  ): Promise<void> => {\n    const { modifiers = {}, delayMs = 0 } = options\n    await emitMouseEvent(\"down\", x, y, button, { modifiers, delayMs })\n  }\n\n  const release = async (\n    x: number,\n    y: number,\n    button: MouseButton = MouseButtons.LEFT,\n    options: MouseEventOptions = {},\n  ): Promise<void> => {\n    const { modifiers = {}, delayMs = 0 } = options\n    await emitMouseEvent(\"up\", x, y, button, { modifiers, delayMs })\n  }\n\n  const drag = async (\n    startX: number,\n    startY: number,\n    endX: number,\n    endY: number,\n    button: MouseButton = MouseButtons.LEFT,\n    options: MouseEventOptions = {},\n  ): Promise<void> => {\n    const { delayMs = 10, modifiers = {} } = options\n\n    await pressDown(startX, startY, button, { modifiers })\n\n    const steps = 5\n    const dx = (endX - startX) / steps\n    const dy = (endY - startY) / steps\n\n    for (let i = 1; i <= steps; i++) {\n      const currentX = Math.round(startX + dx * i)\n      const currentY = Math.round(startY + dy * i)\n      await emitMouseEvent(\"drag\", currentX, currentY, button, { modifiers, delayMs })\n    }\n\n    await release(endX, endY, button, { modifiers })\n  }\n\n  const scroll = async (\n    x: number,\n    y: number,\n    direction: \"up\" | \"down\" | \"left\" | \"right\",\n    options: MouseEventOptions = {},\n  ): Promise<void> => {\n    const { modifiers = {}, delayMs = 0 } = options\n\n    let button: MouseButton\n    switch (direction) {\n      case \"up\":\n        button = MouseButtons.WHEEL_UP\n        break\n      case \"down\":\n        button = MouseButtons.WHEEL_DOWN\n        break\n      case \"left\":\n        button = MouseButtons.WHEEL_LEFT\n        break\n      case \"right\":\n        button = MouseButtons.WHEEL_RIGHT\n        break\n    }\n\n    await emitMouseEvent(\"scroll\", x, y, button, { modifiers, delayMs })\n  }\n\n  const getCurrentPosition = (): MousePosition => {\n    return { ...currentPosition }\n  }\n\n  const getPressedButtons = (): MouseButton[] => {\n    return Array.from(buttonsPressed)\n  }\n\n  return {\n    // Core interaction methods\n    moveTo,\n    click,\n    doubleClick,\n    pressDown,\n    release,\n    drag,\n    scroll,\n\n    // State getters\n    getCurrentPosition,\n    getPressedButtons,\n\n    // Low-level event emission (for advanced use cases)\n    emitMouseEvent,\n  }\n}\n",
    "import { TreeSitterClient } from \"../lib/tree-sitter\"\nimport type { SimpleHighlight } from \"../lib/tree-sitter/types\"\n\nexport class MockTreeSitterClient extends TreeSitterClient {\n  private _highlightPromises: Array<{\n    promise: Promise<{ highlights?: SimpleHighlight[]; warning?: string; error?: string }>\n    resolve: (result: { highlights?: SimpleHighlight[]; warning?: string; error?: string }) => void\n    timeout?: ReturnType<typeof setTimeout>\n  }> = []\n  private _mockResult: { highlights?: SimpleHighlight[]; warning?: string; error?: string } = { highlights: [] }\n  private _autoResolveTimeout?: number\n\n  constructor(options?: { autoResolveTimeout?: number }) {\n    super({ dataPath: \"/tmp/mock\" })\n    this._autoResolveTimeout = options?.autoResolveTimeout\n  }\n\n  async highlightOnce(\n    content: string,\n    filetype: string,\n  ): Promise<{ highlights?: SimpleHighlight[]; warning?: string; error?: string }> {\n    const { promise, resolve } = Promise.withResolvers<{\n      highlights?: SimpleHighlight[]\n      warning?: string\n      error?: string\n    }>()\n\n    let timeout: ReturnType<typeof setTimeout> | undefined\n\n    if (this._autoResolveTimeout !== undefined) {\n      timeout = setTimeout(() => {\n        const index = this._highlightPromises.findIndex((p) => p.promise === promise)\n        if (index !== -1) {\n          resolve(this._mockResult)\n          this._highlightPromises.splice(index, 1)\n        }\n      }, this._autoResolveTimeout)\n    }\n\n    this._highlightPromises.push({ promise, resolve, timeout })\n\n    return promise\n  }\n\n  setMockResult(result: { highlights?: SimpleHighlight[]; warning?: string; error?: string }) {\n    this._mockResult = result\n  }\n\n  resolveHighlightOnce(index: number = 0) {\n    if (index >= 0 && index < this._highlightPromises.length) {\n      const item = this._highlightPromises[index]\n      if (item.timeout) {\n        clearTimeout(item.timeout)\n      }\n      item.resolve(this._mockResult)\n      this._highlightPromises.splice(index, 1)\n    }\n  }\n\n  resolveAllHighlightOnce() {\n    for (const { resolve, timeout } of this._highlightPromises) {\n      if (timeout) {\n        clearTimeout(timeout)\n      }\n      resolve(this._mockResult)\n    }\n    this._highlightPromises = []\n  }\n\n  isHighlighting(): boolean {\n    return this._highlightPromises.length > 0\n  }\n}\n",
    "export function createSpy() {\n  const calls: any[][] = []\n  const spy = (...args: any[]) => {\n    calls.push(args)\n  }\n  spy.calls = calls\n  spy.callCount = () => calls.length\n  spy.calledWith = (...expected: any[]) => {\n    return calls.some((call) => JSON.stringify(call) === JSON.stringify(expected))\n  }\n  spy.reset = () => (calls.length = 0)\n  return spy\n}\n",
    "import type { TestRenderer } from \"./test-renderer\"\n\nexport interface RecordBuffersOptions {\n  fg?: boolean\n  bg?: boolean\n  attributes?: boolean\n}\n\nexport interface RecordedBuffers {\n  fg?: Float32Array\n  bg?: Float32Array\n  attributes?: Uint8Array\n}\n\nexport interface RecordedFrame {\n  frame: string\n  timestamp: number\n  frameNumber: number\n  buffers?: RecordedBuffers\n}\n\nexport interface TestRecorderOptions {\n  recordBuffers?: RecordBuffersOptions\n  now?: () => number\n}\n\n/**\n * TestRecorder records frames from a TestRenderer by hooking into the render pipeline.\n * It captures the character frame after each native render pass.\n */\nexport class TestRecorder {\n  private renderer: TestRenderer\n  private frames: RecordedFrame[] = []\n  private recording: boolean = false\n  private frameNumber: number = 0\n  private startTime: number = 0\n  private originalRenderNative?: () => void\n  private decoder = new TextDecoder()\n  private recordBuffers: RecordBuffersOptions\n  private now: () => number\n\n  constructor(renderer: TestRenderer, options?: TestRecorderOptions) {\n    this.renderer = renderer\n    this.recordBuffers = options?.recordBuffers || {}\n    this.now = options?.now ?? (() => performance.now())\n  }\n\n  /**\n   * Start recording frames. This hooks into the renderer's renderNative method.\n   */\n  public rec(): void {\n    if (this.recording) {\n      return\n    }\n\n    this.recording = true\n    this.frames = []\n    this.frameNumber = 0\n    this.startTime = this.now()\n\n    // Store the original renderNative method\n    this.originalRenderNative = this.renderer[\"renderNative\"].bind(this.renderer)\n\n    // Override renderNative to capture frames after each render\n    this.renderer[\"renderNative\"] = () => {\n      // Call the original renderNative\n      this.originalRenderNative!()\n\n      // Capture the frame after rendering\n      this.captureFrame()\n    }\n  }\n\n  /**\n   * Stop recording frames and restore the original renderNative method.\n   */\n  public stop(): void {\n    if (!this.recording) {\n      return\n    }\n\n    this.recording = false\n\n    // Restore the original renderNative method\n    if (this.originalRenderNative) {\n      this.renderer[\"renderNative\"] = this.originalRenderNative\n      this.originalRenderNative = undefined\n    }\n  }\n\n  /**\n   * Get the recorded frames.\n   */\n  public get recordedFrames(): RecordedFrame[] {\n    return [...this.frames]\n  }\n\n  /**\n   * Clear all recorded frames.\n   */\n  public clear(): void {\n    this.frames = []\n    this.frameNumber = 0\n  }\n\n  /**\n   * Check if currently recording.\n   */\n  public get isRecording(): boolean {\n    return this.recording\n  }\n\n  /**\n   * Capture the current frame from the renderer's buffer.\n   */\n  private captureFrame(): void {\n    const currentBuffer = this.renderer.currentRenderBuffer\n    const frameBytes = currentBuffer.getRealCharBytes(true)\n    const frame = this.decoder.decode(frameBytes)\n\n    const recordedFrame: RecordedFrame = {\n      frame,\n      timestamp: this.now() - this.startTime,\n      frameNumber: this.frameNumber++,\n    }\n\n    // Optionally record buffer data from currentRenderBuffer\n    if (this.recordBuffers.fg || this.recordBuffers.bg || this.recordBuffers.attributes) {\n      const buffers = currentBuffer.buffers\n      recordedFrame.buffers = {}\n\n      if (this.recordBuffers.fg) {\n        recordedFrame.buffers.fg = new Float32Array(buffers.fg)\n      }\n      if (this.recordBuffers.bg) {\n        recordedFrame.buffers.bg = new Float32Array(buffers.bg)\n      }\n      if (this.recordBuffers.attributes) {\n        recordedFrame.buffers.attributes = new Uint8Array(buffers.attributes)\n      }\n    }\n\n    this.frames.push(recordedFrame)\n  }\n}\n"
  ],
  "mappings": "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",
  "debugId": "AFDC9814D38CE45964756E2164756E21",
  "names": []
}